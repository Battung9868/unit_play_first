workflows:
  ios_appstore_signing:
    name: "iOS App Store (Unity Xcode, auto → manual fallback)"
    max_build_duration: 60

    environment:
      groups:
        - signing
        - appstore_connect
      vars:
        BUNDLE_ID: io.battung.brightbins
        DEVELOPMENT_TEAM: R35GJ22D76
        SCHEME: Unity-iPhone
        XCODE_PROJECT: "Unity-iPhone.xcodeproj"
        EXPORT_METHOD: app-store-connect   # для Xcode 16; можно app-store

    scripts:
      - name: "Git LFS (Unity бинарники)"
        script: |
          set -euo pipefail
          git lfs install
          git lfs fetch
          git lfs checkout

      - name: "Импорт сертификата и профиля"
        script: |
          set -euo pipefail

          # --- Keychain ---
          KEYCHAIN_NAME=cm.keychain
          KEYCHAIN_PASS="$(uuidgen)"
          security create-keychain -p "$KEYCHAIN_PASS" "$KEYCHAIN_NAME"
          security set-keychain-settings "$KEYCHAIN_NAME"
          security unlock-keychain -p "$KEYCHAIN_PASS" "$KEYCHAIN_NAME"
          security list-keychains -d user -s "$KEYCHAIN_NAME"
          security default-keychain -s "$KEYCHAIN_NAME"

          # --- Сертификат (.p12 в base64 или путь) ---
          : "${CERTIFICATE_PASSWORD:?Missing CERTIFICATE_PASSWORD}"
          if [[ -z "${CERTIFICATE_P12:-}" ]]; then
            echo "❌ CERTIFICATE_P12 not provided"; exit 1
          fi
          CERT_FILE="cert.p12"
          if [[ -f "$CERTIFICATE_P12" ]]; then
            echo "Using CERTIFICATE_P12 as file path"
            CERT_FILE="$CERTIFICATE_P12"
          else
            echo "Decoding CERTIFICATE_P12 from base64 → cert.p12"
            printf "%s" "$CERTIFICATE_P12" | base64 --decode > "$CERT_FILE"
          fi

          security import "$CERT_FILE" -k "$KEYCHAIN_NAME" -P "$CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security -A
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASS" "$KEYCHAIN_NAME"
          echo "== Identities =="
          security find-identity -v -p codesigning "$KEYCHAIN_NAME" || true

          # --- Профиль (.mobileprovision в base64 или путь) ---
          if [[ -z "${MOBILEPROVISION:-}" ]]; then
            echo "❌ MOBILEPROVISION not provided"; exit 1
          fi
          PROF_FILE="profile.mobileprovision"
          if [[ -f "$MOBILEPROVISION" ]]; then
            echo "Using MOBILEPROVISION as file path"
            PROF_FILE="$MOBILEPROVISION"
          else
            echo "Decoding MOBILEPROVISION from base64 → profile.mobileprovision"
            printf "%s" "$MOBILEPROVISION" | base64 --decode > "$PROF_FILE"
          fi

          PROFILE_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PROFILE_DIR"

          TMP_PLIST="$(mktemp -t prov.plist)"
          security cms -D -i "$PROF_FILE" > "$TMP_PLIST"

          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print UUID" "$TMP_PLIST")
          PROFILE_NAME_DETECTED=$(/usr/libexec/PlistBuddy -c "Print Name" "$TMP_PLIST" 2>/dev/null || echo "")
          APP_IDENTIFIER=$(/usr/libexec/PlistBuddy -c "Print Entitlements:application-identifier" "$TMP_PLIST" 2>/dev/null || echo "")
          GET_TASK_ALLOW=$(/usr/libexec/PlistBuddy -c "Print Entitlements:get-task-allow" "$TMP_PLIST" 2>/dev/null || echo "nil")

          cp "$PROF_FILE" "$PROFILE_DIR/$PROFILE_UUID.mobileprovision"

          echo "PROFILE_UUID=$PROFILE_UUID"
          echo "PROFILE_NAME=$PROFILE_NAME_DETECTED"
          echo "application-identifier=$APP_IDENTIFIER"
          echo "get-task-allow=$GET_TASK_ALLOW"

          # Жёсткая проверка соответствия bundle id и типа профиля
          if [[ "$GET_TASK_ALLOW" != "false" ]]; then
            echo "❌ Это не App Store Distribution профиль (get-task-allow должен быть false)"; exit 1
          fi
          EXPECTED_AI="${DEVELOPMENT_TEAM}.${BUNDLE_ID}"
          if [[ "$APP_IDENTIFIER" != "$EXPECTED_AI" ]]; then
            echo "❌ Профиль выпущен не под $BUNDLE_ID (ожидали $EXPECTED_AI)"; exit 1
          fi

          # Сохраним имя/uuid для следующего шага
          echo "PROFILE_UUID=$PROFILE_UUID" >> $CM_ENV
          echo "PROFILE_NAME=$PROFILE_NAME_DETECTED" >> $CM_ENV

      - name: "Sanity: .xcodeproj exists"
        script: |
          set -euo pipefail
          test -d "$XCODE_PROJECT" || { echo "ERROR: не найден проект: $XCODE_PROJECT"; exit 1; }
          echo "OK: проект найден: $XCODE_PROJECT"

      - name: "Archive and export IPA (auto → manual)"
        script: |
          set -euo pipefail
          source "$CM_ENV" || true

          : "${DEVELOPMENT_TEAM:?Missing DEVELOPMENT_TEAM}"
          : "${BUNDLE_ID:?Missing BUNDLE_ID}"
          : "${EXPORT_METHOD:?Missing EXPORT_METHOD}"
          : "${XCODE_PROJECT:?Missing XCODE_PROJECT}"

          CHOSEN_SCHEME="${SCHEME:-Unity-iPhone}"
          echo "Archive scheme: $CHOSEN_SCHEME"

          ARCHIVE_PATH="$CM_BUILD_DIR/app.xcarchive"
          CM_EXPORT_DIR="${CM_EXPORT_DIR:-$CM_BUILD_DIR/Export}"
          mkdir -p "$CM_EXPORT_DIR"

          # Архив без подписи
          xcodebuild -resolvePackageDependencies -project "$XCODE_PROJECT" -scheme "$CHOSEN_SCHEME"
          xcodebuild archive \
            -project "$XCODE_PROJECT" \
            -scheme "$CHOSEN_SCHEME" \
            -configuration Release \
            -archivePath "$ARCHIVE_PATH" \
            DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO | tee "$CM_BUILD_DIR/xcodebuild-archive.log"

          # Для отладки: bundle id в архиве
          if [[ -f "$ARCHIVE_PATH/Info.plist" ]]; then
            echo "Archive bundle id:"
            /usr/libexec/PlistBuddy -c "Print ApplicationProperties:CFBundleIdentifier" "$ARCHIVE_PATH/Info.plist" || true
          fi

          # --- exportOptions_auto.plist без here-doc ---
          AUTO_PLIST="$CM_BUILD_DIR/exportOptions_auto.plist"
          /usr/libexec/PlistBuddy -c "Clear dict" "$AUTO_PLIST" 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :method string $EXPORT_METHOD" "$AUTO_PLIST"
          /usr/libexec/PlistBuddy -c "Add :teamID string $DEVELOPMENT_TEAM" "$AUTO_PLIST"
          /usr/libexec/PlistBuddy -c "Add :signingStyle string automatic" "$AUTO_PLIST"
          /usr/libexec/PlistBuddy -c "Add :destination string export" "$AUTO_PLIST"
          /usr/libexec/PlistBuddy -c "Add :compileBitcode bool false" "$AUTO_PLIST"
          /usr/libexec/PlistBuddy -c "Add :uploadBitcode bool false" "$AUTO_PLIST"

          set +e
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportOptionsPlist "$AUTO_PLIST" \
            -exportPath "$CM_EXPORT_DIR" | tee "$CM_BUILD_DIR/xcodebuild-export.log"
          XCB_RET=$?
          set -e

          IPA_PATH="$(find "$CM_EXPORT_DIR" -name '*.ipa' -print -quit || true)"
          if [[ "$XCB_RET" -ne 0 || -z "$IPA_PATH" ]]; then
            echo "Auto export failed → пробуем ручной профиль только для $BUNDLE_ID"

            MANUAL_PLIST="$CM_BUILD_DIR/exportOptions_manual.plist"
            /usr/libexec/PlistBuddy -c "Clear dict" "$MANUAL_PLIST" 2>/dev/null || true
            /usr/libexec/PlistBuddy -c "Add :method string $EXPORT_METHOD" "$MANUAL_PLIST"
            /usr/libexec/PlistBuddy -c "Add :teamID string $DEVELOPMENT_TEAM" "$MANUAL_PLIST"
            /usr/libexec/PlistBuddy -c "Add :signingStyle string manual" "$MANUAL_PLIST"
            /usr/libexec/PlistBuddy -c "Add :destination string export" "$MANUAL_PLIST"
            /usr/libexec/PlistBuddy -c "Add :compileBitcode bool false" "$MANUAL_PLIST"
            /usr/libexec/PlistBuddy -c "Add :uploadBitcode bool false" "$MANUAL_PLIST"
            /usr/libexec/PlistBuddy -c "Add :provisioningProfiles dict" "$MANUAL_PLIST"
            # В exportOptions требуется имя профиля (Name). UUID обычно тоже работает, но Name надёжнее.
            /usr/libexec/PlistBuddy -c "Add :provisioningProfiles:$BUNDLE_ID string ${PROFILE_NAME:-$PROFILE_NAME_DETECTED}" "$MANUAL_PLIST"
            # Можно дополнительно подсказать сертификат:
            /usr/libexec/PlistBuddy -c "Add :signingCertificate string Apple Distribution" "$MANUAL_PLIST" || true

            set +e
            xcodebuild -exportArchive \
              -archivePath "$ARCHIVE_PATH" \
              -exportOptionsPlist "$MANUAL_PLIST" \
              -exportPath "$CM_EXPORT_DIR" | tee -a "$CM_BUILD_DIR/xcodebuild-export.log"
            XCB_RET=$?
            set -e

            IPA_PATH="$(find "$CM_EXPORT_DIR" -name '*.ipa' -print -quit || true)"
            if [[ "$XCB_RET" -ne 0 || -z "$IPA_PATH" ]]; then
              echo "❌ IPA не создана. Хвост лога экспорта:"
              tail -n 200 "$CM_BUILD_DIR/xcodebuild-export.log" || true
              exit 1
            fi
          fi

          echo "✅ IPA created: $IPA_PATH"
          echo "Export dir content:"
          find "$CM_EXPORT_DIR" -maxdepth 2 -type f -print || true

    artifacts:
      - $CM_BUILD_DIR/xcodebuild-archive.log
      - $CM_BUILD_DIR/xcodebuild-export.log
      - $CM_EXPORT_DIR/*.ipa
      - $CM_EXPORT_DIR/*.dSYM.zip
      - $CM_BUILD_DIR/*.xcarchive

    publishing:
      app_store_connect:
        api_key: $APP_STORE_CONNECT_PRIVATE_KEY
        key_id: $APP_STORE_CONNECT_KEY_IDENTIFIER
        issuer_id: $APP_STORE_CONNECT_ISSUER_ID

        submit_to_testflight: true
        submit_to_app_store: true
        cancel_previous_submissions: true
        release_type: MANUAL
